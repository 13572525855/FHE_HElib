			2014/12/02 11:11  星期二
主机环境：
	Memory: 2G
	Centos6.0
	gcc 4.8
	Qt4.8.4
	ntl-7.0.0
用Qt编写了两个程序cli_FHE和ser_FHE。在一台主机上分别模拟客户端和服务器
实现了：
	1. 客户端对简单数据加密得到密文ct1,ct2
	2. 将密文发送给服务器
	3. 服务器对密文ct1,ct2分别进行加法、乘法运算
	4. 服务器将计算结果ctSum,ctProd返回客户端
	5. 客户端对收到的密文解密得到运算结果
存在的问题：
	1. 密文构造很不灵活，只能固定构造密文ct1,ct2
	2. 只能对简单的数字操作
	3. 运算的结果返回到客户端解密后结果并不正确,预测是密钥的操作有问题
其他文件说明：
	1. cli和ser是简单的文件上传下载程序，ser_FHE和cli_FHE所用的网络传输功能目
	前都是基于此程序改编
	2. libfhe.a全同态加密库目前只能编译成这样(Shai也这样说)，没有像ntl库那样合
	理紧密的库编译方式

			2014/12/03 10:51  星期三
	上次“存在的问题”第3点提到预测可能是密钥的操作有问题，经调试，是socket套接字传输时出现"数据重复"造成的，比如:第一次发111，收到111，第二次发222，收到的就是111222，而不是期望中的222。这个问题是因为客户端第一次发送完数据后没有刷新缓冲区
	我试过oss.flush和oss.str().clear都不行，这两个方法的功能貌似是出现错误的时候刷新，最后查了<a href="http://stackoverflow.com/questions/20731/in-c/how-do-you-clear-a-stringstream-variable">overstackflow</a>，解决办法是oss.str("")；或oss.str(std::string());
	存在的问题：
	1.服务器使用和客户端一样的参数生成公钥，公钥并不是客户端传过来的，因此还没有真正的做到对服务器端隐私
	2. 数据构造还是很僵硬
			
			2014/12/06 09:16  星期六
	上次解决完传输数据过程中"数据重复"的问题之后。工作并没有告一段落，因为服务器端是使用和客户端一样的参数来构造密钥和公钥，在实际应用中，当然不可能让服务器端自己构造密钥，显然这样全同态就没有意义了。所以，接下来的目标是客户端只给服务器端传包含有m,p,r参数的FHEcontext和公钥，服务器端利用收到的FHEcontext构造公钥对象，以后的所有计算都基于公钥。
	1. 为了使运算数据和公钥隔离，新建一个文件iotest.txt保存FHEcontext和公钥
	2. 在确定一些注释代码不再需要的时候可以果断的删除，很多时候调试会被干扰
	3. 当在一台主机上多次运行程序时，会发现生成的密钥key都相等，这是因为NTL库中伪随机数种子的原因，HElib issue #37
	期间遇到很多问题，为此还上github问shai,很开心有shai的亲自回复！
	
	接下来的工作：
	1. 自由构造符合条件的字符数据，当前的vector数据对象太僵硬
	2. 进度快的话尝试开发界面	

	这一次提交删除了一些没用的文件，如libfhe.a目录下测试用的执行文件Test_**_x
		
	








